<!doctype html>
<html lang="en">
  <head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=livereload" data-no-instant defer></script>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="author" content="Ronalds Vilcins - http://localhost:1313/">
  <title> | Vinay Kumar</title>
  <meta name="description" content="Blogs &amp; Articles on Machine Learning by @imflash217">
<meta name="twitter:card" content="summary"/><meta name="twitter:title" content=""/>
<meta name="twitter:description" content="1.1: Unpacking a sequence into separate variables # ???&#43; danger &ldquo;Problem&rdquo; You have a N-element tuple or sequence that you would like to unpack into a collection of N variables.
???&#43; done &ldquo;Solution&rdquo; 1. Any sequence or iterable can be unpacked into variables using a simple assignment operation. 2. The only requirement is that the the number of variables and structure of the sequence must match.
```python ##---------------------------------------------------------- p = (4,5) ## create a tuple x, y = p ## unpack the tuple into variables &#39;x&#39; &amp; &#39;y&#39;."/>

<meta property="og:title" content="" />
<meta property="og:description" content="1.1: Unpacking a sequence into separate variables # ???&#43; danger &ldquo;Problem&rdquo; You have a N-element tuple or sequence that you would like to unpack into a collection of N variables.
???&#43; done &ldquo;Solution&rdquo; 1. Any sequence or iterable can be unpacked into variables using a simple assignment operation. 2. The only requirement is that the the number of variables and structure of the sequence must match.
```python ##---------------------------------------------------------- p = (4,5) ## create a tuple x, y = p ## unpack the tuple into variables &#39;x&#39; &amp; &#39;y&#39;." />
<meta property="og:type" content="article" />
<meta property="og:url" content="http://localhost:1313/post/python/cookbook_dabeaz/ch01/" /><meta property="article:section" content="post" />




<meta itemprop="name" content="">
<meta itemprop="description" content="1.1: Unpacking a sequence into separate variables # ???&#43; danger &ldquo;Problem&rdquo; You have a N-element tuple or sequence that you would like to unpack into a collection of N variables.
???&#43; done &ldquo;Solution&rdquo; 1. Any sequence or iterable can be unpacked into variables using a simple assignment operation. 2. The only requirement is that the the number of variables and structure of the sequence must match.
```python ##---------------------------------------------------------- p = (4,5) ## create a tuple x, y = p ## unpack the tuple into variables &#39;x&#39; &amp; &#39;y&#39;.">

<meta itemprop="wordCount" content="3082">
<meta itemprop="keywords" content="" />
  <link rel="canonical" href="http://localhost:1313/post/python/cookbook_dabeaz/ch01/">
  <link rel="dns-prefetch" href="https://www.google-analytics.com">
  <link href="https://www.google-analytics.com" rel="preconnect" crossorigin>
  <link rel="alternate" type="application/atom+xml" title="Vinay Kumar" href="http://localhost:1313/atom.xml" />
  <link rel="alternate" type="application/json" title="Vinay Kumar" href="http://localhost:1313/feed.json" />
  <link rel="shortcut icon" type="image/png" href="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAQAAAC1HAwCAAAAC0lEQVR42mNk+A8AAQUBAScY42YAAAAASUVORK5CYII=">
  
  <style>*,:after,:before{box-sizing:border-box;padding:0}body{font:1rem/1.5 '-apple-system',BlinkMacSystemFont,avenir next,avenir,helvetica,helvetica neue,ubuntu,roboto,noto,segoe ui,arial,sans-serif;text-rendering:optimizeSpeed}.posts hr{margin-top:0;margin-bottom:0;margin-right:.5rem;margin-left:.5rem;height:1px;border:none;border-bottom:1px #353535;flex:1 0 1rem}main{max-width:70ch;padding:2ch;margin:auto}a,body{color:#353535}::selection,a:focus,a:hover{background-color:#353535;color:#fff}.meta{margin:0 0 2.5rem}.tags::before{content:"\2022";margin-left:1rem}code,pre{color:#353535;font-family:San Francisco Mono,Monaco,consolas,lucida console,dejavu sans mono,bitstream vera sans mono,monospace;font-size:normal;border:1px solid #353535;font-size:small}.highlight [class^=language-]{color:#fff}code{padding:.1rem;border:none}pre{padding:.5rem;overflow-x:auto}pre code{border:none}img{max-width:100%;border:1px solid #353535}hr{background:#353535;height:1px;border:0}ul{list-style-type:square}ul,ol{padding-left:1.2rem}header li,footer li{display:inline;text-transform:uppercase}header a,footer a{text-decoration:none}header ul,footer ul{justify-content:space-between;display:flex}[aria-current=page]{text-decoration:line-through}header,section,footer{padding:1rem 0}blockquote{border-left:5px solid #353535;padding-left:1rem}.posts ul,header ul,footer ul{list-style:none}.posts,header ul,footer ul{padding:0}.posts li{align-items:center;display:flex;justify-content:space-between;margin-bottom:.7rem}.posts li a,.posts li div{white-space:nowrap;overflow:hidden;text-overflow:ellipsis;text-decoration:none}.posts li time{padding-left:1rem;white-space:nowrap;font-variant-numeric:tabular-nums}.hash{opacity:.25;text-decoration:none}table{border-collapse:collapse;text-align:left;width:100%}table tr{background:#fff;border-bottom:1px solid}table th,table td{padding:10px 20px}</style>

  


<script type="application/ld+json">
{
    "@context": "http://schema.org",
    "@type": "BlogPosting",
    "articleSection": "post",
    "name": "",
    "headline": "",
    "alternativeHeadline": "",
    "description": "1.1: Unpacking a sequence into separate variables # ???\u002b danger \u0026ldquo;Problem\u0026rdquo; You have a N-element tuple or sequence that you would like to unpack into a collection of N variables.\n???\u002b done \u0026ldquo;Solution\u0026rdquo; 1. Any sequence or iterable can be unpacked into variables using a simple assignment operation. 2. The only requirement is that the the number of variables and structure of the sequence must match.\n\u0060\u0060\u0060python ##---------------------------------------------------------- p = (4,5) ## create a tuple x, y = p ## unpack the tuple into variables \u0027x\u0027 \u0026amp; \u0027y\u0027.",
    "inLanguage": "en",
    "isFamilyFriendly": "true",
    "mainEntityOfPage": {
        "@type": "WebPage",
        "@id": "http:\/\/localhost:1313\/post\/python\/cookbook_dabeaz\/ch01\/"
    },
    "author" : {
        "@type": "Person",
        "name": ""
    },
    "creator" : {
        "@type": "Person",
        "name": ""
    },
    "accountablePerson" : {
        "@type": "Person",
        "name": ""
    },
    "copyrightHolder" : "Vinay Kumar",
    "copyrightYear" : "0001",
    "dateCreated": "0001-01-01T00:00:00.00Z",
    "datePublished": "0001-01-01T00:00:00.00Z",
    "dateModified": "0001-01-01T00:00:00.00Z",
    "publisher":{
        "@type":"Organization",
        "name": "Vinay Kumar",
        "url": "http://localhost:1313/",
        "logo": {
            "@type": "ImageObject",
            "url": "http:\/\/localhost:1313\/",
            "width":"32",
            "height":"32"
        }
    },
    "image": "http://localhost:1313/",
    "url" : "http:\/\/localhost:1313\/post\/python\/cookbook_dabeaz\/ch01\/",
    "wordCount" : "3082",
    "genre" : [ ],
    "keywords" : [ ]
}
</script>


</head>
<body>
<main>
      <header>
    <nav>
      
  <ul>
    <li>
      
      
      
      
      <a href="archives" >Archive</a>
    </li>
  
    <li>
      
      
      
      
      <a href="search/" >Search</a>
    </li>
  
    <li>
      
      
      
      
      <a href="tags/" >Tags</a>
    </li>
  
    <li>
      
      
      
      
      <a href="https://www.github.com/imflash217/" >Github</a>
    </li>
  
    <li>
      
      
      
      
      <a href="https://www.linkedin.com/in/imflash217" >LinkedIn</a>
    </li>
  
  </ul>
    </nav>
  </header>
  <hr>



  <section>

      

      <span itemprop="articleBody">
      <!-- ---
hide:
  - navigation # Hide navigation
  - toc        # Hide table of contents
--- -->
<!-- ######################################################################################################### -->
<h2 id="11-unpacking-a-sequence-into-separate-variables">1.1: Unpacking a sequence into separate variables <a href="#11-unpacking-a-sequence-into-separate-variables" class="hash">#</a></h2>
<p>???+ danger &ldquo;Problem&rdquo;
You have a <code>N-element</code> tuple or sequence that you would like to unpack into a collection of <code>N</code> variables.</p>
<p>???+ done &ldquo;Solution&rdquo;
1. Any <strong>sequence</strong> or <strong>iterable</strong> can be unpacked into variables using a simple assignment operation.
2. The only requirement is that the <strong>the number of variables and structure of the sequence must match</strong>.</p>
<pre><code>```python
##----------------------------------------------------------
p = (4,5)   ## create a tuple
x, y = p    ## unpack the tuple into variables 'x' &amp; 'y'. 
            ## x=4; y=5
##----------------------------------------------------------
data = [&quot;ACME&quot;, 50, 91.1, (2021,10,07)]
name, shares, price, date = data    ## unpack the list
                                    ## name=&quot;ACME&quot;; shares=50
                                    ## price=91.1; date=(2021,10,07)

## another way to unpack the nested iterable or container
## name=&quot;ACME&quot;; shares=50; price=91.1; 
## year = 2021; month=10; day=07
name, shares, price, (year, month, day) = data
```

If there is a mismatch in the number of elements; you will get an ERROR.
```python
p = (4, 5)
x, y, z = p
```
```zsh
Traceback (most recent call last):
    File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;
    ValueError: need more than 2 values to unpack
```
</code></pre>
<p>???+ quote &ldquo;Discussion&rdquo;
Unpacking actually works with any object that happens to be <strong>iterable</strong> (tuples, lists, dicts, str, files, iteratirs, generators&hellip;)</p>
<!-- ######################################################################################################### -->
<h2 id="12-unpacking-elements-from-iterables-of-arbitrary-length">1.2: Unpacking elements from iterables of arbitrary length <a href="#12-unpacking-elements-from-iterables-of-arbitrary-length" class="hash">#</a></h2>
<p>???+ danger &ldquo;Problem&rdquo;
You need to unpack <code>N</code> elements from an <strong>iterable</strong>; but the iterable may be longer than <code>N</code> elements (causing a <code>too many values to unpack</code> exception)</p>
<p>???+ done &ldquo;Solution&rdquo;</p>
<!-- ######################################################################################################### -->
<h2 id="13-keeping-last-n-items">1.3 Keeping last N items <a href="#13-keeping-last-n-items" class="hash">#</a></h2>
<p>???+ danger &ldquo;Problem&rdquo;
You want to keep a limited history of last few items seen during iteration.</p>
<p>???+ done &ldquo;Solution&rdquo;
1. Keeping a limited history is a perfect use for <code>collections.deque</code></p>
<pre><code>```python
&quot;&quot;&quot;
Performs a simple text match on a sequence of lines
and yields the matching line &amp; previous N lines of context when found
&quot;&quot;&quot;

from collections import deque

def search(lines, pattern, history=5):
    previous_lines = deque(maxlen=history)
    for line in lines:
        if pattern in line:
            yield line, previous_lines
        previous_lines.append(line)

##-----------------------------------------------------------##
## Example use ona file
if __name__ == &quot;__main__&quot;:
    with open(&quot;somefile.txt&quot;, &quot;r&quot;) as f:
        for line, prev_lines in search(f, &quot;my_pattern&quot;):
            for x in lines:
                print(x, end=&quot;&quot;)
            print(line, end=&quot;&quot;)
            print(&quot;--&quot;*10)
```
</code></pre>
<!-- ######################################################################################################### -->
<h2 id="15-priority-queue">1.5: Priority Queue <a href="#15-priority-queue" class="hash">#</a></h2>
<p>???+ danger &ldquo;Problem&rdquo;
You want to implement a <code>queue</code> that sorts items by a given priority
&amp; always <strong>returns the item with highest priority</strong> on each <code>pop</code> operation.</p>
<p>???+ done &ldquo;Solution&rdquo;
The following class uses <code>heapq</code> module to implement a simple <strong>priority queue</strong></p>
<pre><code>```python
import heapq

class PriorityQueue:
    def __init__(self):
        self._queue = []
        self._idx = 0

    def __repr__(self):
        return self._queue

    def push(self, item, priority):
        
        ## because heappop returns the 1st item in the queue 
        ## (which has the smallest priority);
        ## So, we need to invert the priority as (-priority)
        ## Thus, we get the item with highest priority on pop

        heapq.heappush(self._queue, (-priority, self._idx, item))
        self._idx += 1

    def pop(self):
        &quot;&quot;&quot;
        Returns item with HIGHEST priority in the priority queue
        &quot;&quot;&quot;
        result = heapq.heappop(self._queue)     ## a tuple of type (-priority, idx, item)
        return result[-1]                       ## &quot;item&quot; from above line
```

Here is an example of how we might use the above `PriorityQueue` class

```python
class Item:
    def __init__(self, name):
        self.name = name

    def __repr__(self):
        return f&quot;Item({self.name})&quot;

##-----------------------------------------------------------##

q = PriorityQueue()                 ## Create a priority-queue object
q.push(Item(&quot;foo&quot;), priority=1)     ## push an Item(&quot;foo&quot;) with priority=1
q.push(Item(&quot;bar&quot;), priority=5)     ## push an Item(&quot;bar&quot;) with priority=5
q.push(Item(&quot;spam&quot;), priority=4)    ## push an Item(&quot;spam&quot;) with priority=4
q.push(Item(&quot;grok&quot;), priority=1)    ## push an Item(&quot;grok&quot;) with priority=1
    
q.pop()                             ## Item(&quot;bar&quot;)
q.pop()                             ## Item(&quot;spam&quot;)
q.pop()                             ## Item(&quot;foo&quot;)
q.pop()                             ## Item(&quot;grok&quot;)

```

In the above example note that the items with same priority (`Item(&quot;foo&quot;)` and `Item(&quot;grok&quot;)`)
are returned in the same order as they were inserted into the queue.
</code></pre>
<p>???+ quote &ldquo;Discussion&rdquo;
The core of this recipe concerns with the use of <code>heapq</code> module.
The methods <code>heapq.heappush()</code> and <code>heapq.heappop()</code> insert and remove items
from <code>self._queue</code> in such a way that the first tem in the list has the <strong>smallest priority</strong>.</p>
<pre><code>The `heappop()` method always returns the **smallest** item; so that is the key idea to make 
our `PriorityQueue` pop correct items.

In this recipe the queue consists of tuple `(-priority, idx, item)`. 
The `priority` value is negated to get the queue to sort items from 
**highest priority** to **lowest priority**. 
This is opposite from normal heap ordering; which sorts items from smallest to highest value.

The role of the `idx` value is to properly order items with the same priority level.
By keeping a constantly increasing index, the items will be sorted according to the 
order in which they were inserted. 
However, the `idx` also serves an important role in making the comparision work for items
with the smae priority level. To elaborate on this, the instances of `Item` can't be ordered.

```python
## Item class objects cannot be compared; 
## because we have not implemented __eq__, __le__ etc...methods to support it

a = Item(&quot;foo&quot;)
b = Item(&quot;bar&quot;)
a &lt; b                   ## ERROR. 
                        ## because &quot;Item&quot; object cannot be compared.
```
```zsh
Traceback (most recent call last):
  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;
TypeError: unorderable types: Item() &lt; Item()
```

But, if you make (priority, item) tuple and compare them, then it works fine
as long as the priorities are different.

```python
## tuples (priority, item) with different priorities.
## Comparision works fine

a = (1, Item(&quot;foo&quot;))
b = (2, Item(&quot;bar&quot;))
a &lt; b                   ## Returns &quot;True&quot;
                        ## because priority: 1 &lt; 2
```
So, to handle the case of same priority value; the `idx` is used. 
The `idx` is always increasing and unique; so there is no chance of collision as shown below

```python
## Tuples (priority, idx, item) with same priorities but unique idx.
## Comparision works fine

a = (1, 7, Item(&quot;foo&quot;))
b = (1, 8, Item(&quot;bar&quot;))
a &lt; b                   ## Returns &quot;True&quot;
                        ## because idx: 7 &lt; 8 
```
</code></pre>
<!-- ######################################################################################################### -->
<h2 id="16-collectionsdefaultdict">1.6: collections.defaultdict <a href="#16-collectionsdefaultdict" class="hash">#</a></h2>
<p>???+ danger &ldquo;Mapping Keys to multiple values in Dictionary&rdquo;
You want to make a dictionary that maps keys to more than one value
(so called <code>multdict</code>)</p>
<p>???+ done &ldquo;Solution&rdquo;
A dictionary is a <code>mapping</code> where each <code>key</code> is mapped to a single value.
If you want to map keys to <strong>multiple values</strong>; you need to store multiple values
in another container (like <code>list</code> or <code>set</code> or other <code>container types</code>)</p>
<pre><code>```python
d = {&quot;a&quot;: [1,2,3],
     &quot;b&quot;: [4,5],
    }

e = {&quot;a&quot;: {1,2,3},
     &quot;b&quot;: {4,5},
    }
```
1. Use a `list` if you want to **preserve the insertion-order** of items.
2. Use a `set` if you want to **eliminate duplicates**.

To easily construct such dictionaries, you can use **`collections.defaultdict`**.
A feature of `defaultdict` is that it automatically initializes the first value so 
you can simply focus on adding items.

```python
from collections import defaultdict

d = defaultdict(list)               ## use &quot;list&quot; as a constructor to initialize values map for new keys
d[&quot;a&quot;].append(1)                    ## d = {&quot;a&quot;:[1]}
d[&quot;a&quot;].append(2)                    ## d = {&quot;a&quot;:[1,2]}
d[&quot;b&quot;].append(5)                    ## d = {&quot;a&quot;:[1,2], &quot;b&quot;:[5]}
d[&quot;b&quot;].append(5)                    ## d = {&quot;a&quot;:[1,2], &quot;b&quot;:[5,5]}       duplication of 5 is allowed in list
```
```python
from collections import defaultdict

d = defaultdict(set)                ## use &quot;set&quot; as a constructor to initialize values map for new keys
d[&quot;a&quot;].add(1)                       ## d = {&quot;a&quot;: {1}}
d[&quot;a&quot;].add(2)                       ## d = {&quot;a&quot;: {1,2}}
d[&quot;b&quot;].add(5)                       ## d = {&quot;a&quot;: {1,2}, &quot;b&quot;: {5}}
d[&quot;b&quot;].add(5)                       ## d = {&quot;a&quot;: {1,2}, &quot;b&quot;: {5}}       duplicates NOT allowed in &quot;set&quot;
```

**NOTE**: One caution with `defaultdict` is that it will automatically create dictionary entries for
keys accessed later on (**even if they aren't found in the dictionary**) i.e. instead of throwing `KeyError`
for keys that are not found, it adds that key to the dictinary and maps its value to the empty constructor
(`list` or `set` etc. as above).

If you want to avoid this behavior, its better to use usual `dict()` with `setdefault()`.
This process is a bit messy and hard-to-read as shown below; 
but provides user-control to handle edge cases.

```python
d = {}                              ## a regular dictionary
d.setdefault(&quot;a&quot;, []).append(1)     ## d = {&quot;a&quot;: [1]}
d.setdefault(&quot;a&quot;, []).append(2)     ## d = {&quot;a&quot;: [1,2]}
d.setdefault(&quot;b&quot;, []).append(5)     ## d = {&quot;a&quot;: [1,2], &quot;b&quot;: [5]}
```
</code></pre>
<p>???+ quote &ldquo;Discussion&rdquo;
In principle, constructing a multivariate dictionary is simple.
However, initialization of the first value can be messy if you try to do it yourself.
Below two code-snippets show this tradeoff.</p>
<pre><code>```python
d = {}
for key, value in pairs:
    if key not in d:
        d[key] = []
    d[key].append(value)

##--------------- v/s -----------------##

from collections import defaultdict
d = defaultdict()
for key, value in items:
    d[key].append(value)
```
</code></pre>
<!-- ######################################################################################################### -->
<h2 id="19-finding-commonalities-in-two-dictionaries">1.9: Finding commonalities in two dictionaries <a href="#19-finding-commonalities-in-two-dictionaries" class="hash">#</a></h2>
<p>???+ danger &ldquo;Problem&rdquo;
You have two dictionaries and you want to find what they have in common (like same <code>keys</code>, same <code>values</code> etc.)</p>
<p>???+ done &ldquo;Solution&rdquo;
Consider two dictionaries</p>
<pre><code>```python
a = {&quot;x&quot;:1, &quot;y&quot;:2, &quot;z&quot;:3}
b = {&quot;w&quot;:10, &quot;x&quot;:11, &quot;y&quot;:2}
```
To find out what the two dictionaries have in common, simply perform the common set operations
using the `keys()` and `values()` methods.

For example:
```python
## finding keys in common
a.keys() &amp; b.keys()         ##{&quot;x&quot;, &quot;y&quot;}
```

```python
## finding keys in a, that are not in b
a.keys() - b.keys()         ## {&quot;z&quot;}
```

```python hl_lines=&quot;2&quot;
## finding (key, value) pair in common
a.items() &amp; b.items()       ## {(&quot;y&quot;, 2)}
```

These kinds of operations can also be used to **alter** or **filter** dictionary contents.

For, example, suppose you want to make a new dictionary with selected keys removed.
Below is a sample code using a **dictionary comprehension**
```python
## make a new dictionary with certain keys removed
c = {key:a[key] for key in a.keys()-{&quot;z&quot;, &quot;w&quot;}}     ## {&quot;x&quot;:1, &quot;y&quot;:2}
```
</code></pre>
<p>???+ quote &ldquo;Discussion&rdquo;
A <strong>dictionary</strong> is a mapping between a set of <strong>keys</strong> and <strong>values</strong></p>
<pre><code>The **`.keys()`** method on a dict returns **keys-view** object of the dict.
This keys-view object support common **set** operations like **join**, **intersection**, **difference** etc.
These set operations are supported because it is **guranteed** that the keys of a dict are uniquely hashable.

The **`.items()`**  method on a dict returns **items-view** object consisting 
of `(key, value)` pairs. This items-view object also supports common set operations as above.

The **`.values()`** method on the dict returns a **values-view** object consisting of values of the dict.
BUT, this **values-view** object DOES-NOT SUPPORT common set operations 
because the **values of a dict are not guranteed to be unique**.
Although, if necessary we can always convert this _values-view object_ into a _set_ and 
then perform required set-operations as usual.
</code></pre>
<h2 id="110-removing-duplicates-from-a-sequence-maintaining-order">1.10: Removing duplicates from a Sequence (maintaining order) <a href="#110-removing-duplicates-from-a-sequence-maintaining-order" class="hash">#</a></h2>
<p>???+ danger &ldquo;Problem&rdquo;
You want to remove duplicates from the sequence while maintaining order</p>
<p>???+ done &ldquo;Solution&rdquo;
If the values in a <strong>sequence</strong> are hashable, then we solve this problem by using <strong><code>set</code></strong> and <strong><code>generator</code></strong></p>
<pre><code>```python
def dedupe(items):
    seen = set()
    for x in items:
        if x not in seen:
            yield x
            seen.add(x)

##----------------------------------##

a = [1, 5, 2, 1, 9, 1, 5, 10]
list(dedupe(a))                     ## [1, 5, 2, 9, 10]

## NOTE: above the order of the items in the output list is maintained according to the input &quot;a&quot;
```

But this above solution is valid only if the items in the sequence are **hashable**.

For sequences, which have unhashable items (like `dict`), the below solution works:

```python hl_lines=&quot;4&quot;
def dedupe_unhashable(items, key=None):
    seen = set()
    for item in items:
        val = item if key is None else key(item)
        if val not in seen:
            yield item
            seen.add(item)
```

Here, the purpose of the `key` argument is to specify a `function` that converts sequence items
into hashable type for the purpose of _duplicate detection_.
For example:

```python hl_lines=&quot;3&quot;
a = [{&quot;x&quot;:1, &quot;y&quot;:2},
     {&quot;x&quot;:1, &quot;y&quot;:3},
     {&quot;X&quot;:1, &quot;y&quot;:2},
     {&quot;x&quot;:2, &quot;y&quot;:4}
    ]
```

```python
list(dedupe_unhashable(a, key=lambda d: (d[&quot;x&quot;], d[&quot;y&quot;])))
```

``` bash
[{&quot;x&quot;:1, &quot;y&quot;:2},
 {&quot;x&quot;:1, &quot;y&quot;:3},
 {&quot;x&quot;:2, &quot;y&quot;:4}]
```

```python
list(dedupe_unhashable(a, key=lambda d: (d[&quot;x&quot;])))
```

``` bash
[{&quot;x&quot;:1, &quot;y&quot;:2},
 {&quot;x&quot;:2, &quot;y&quot;:4}]
```

This solution will work for any kind of data structure and a `key` function that returns a **hashable** value
</code></pre>
<h2 id="112-frequency-of-items-in-a-sequence">1.12: Frequency of items in a Sequence <a href="#112-frequency-of-items-in-a-sequence" class="hash">#</a></h2>
<p>???+ danger &ldquo;Problem&rdquo;
You have a sequence of <strong>hashable</strong> items asn you would want ot count the frequency
of each item in the sequence.</p>
<p>???+ done &ldquo;Solution&rdquo;
Use <strong><code>collections.Counter</code></strong></p>
<pre><code>Suppose we are give a list of strings `words` as shown below and we want to find 
the frequency of each word in the list

```python
words = [
   'look', 'into', 'my', 'eyes', 'look', 'into', 'my', 'eyes',
   'the', 'eyes', 'the', 'eyes', 'the', 'eyes', 'not', 'around', 'the',
   'eyes', &quot;don't&quot;, 'look', 'around', 'the', 'eyes', 'look', 'into',
   'my', 'eyes', &quot;you're&quot;, 'under'
]
```

```python
from collections import Counter
word_counts = Counter(words)

top_three = word_counts.most_common(3)      ## returns the 3 most common items
print(top_three)                            ## [('eyes', 8), ('the', 5), ('look', 4)]
```

The **`Counter`** class has a method `most_common()` which returns the topn &quot;n&quot; most common
items in the sequence.
</code></pre>
<p>???+ quote &ldquo;Discussion&rdquo;
&#x1f3af; As input, the <code>Counter</code> object can be fed any sequence of <strong>hashable</strong> items.
The <code>Counter</code> object is basically just a <strong>dictionary</strong> that holds the unique items
in the input sequence as its <strong><code>keys</code></strong> and their resepective counts as its <strong><code>values</code></strong>.</p>
<pre><code>:dart: If you want to increment the count **manually**, simply use _addition_ op.

```python
morewords = ['why','are','you','not','looking','in','my','eyes']
for word in morewords:
    word_counts[word] += 1
```

:trophy: Alternative, you can also use **`update`** method on the `Counter` object to 
update the counter object.

```python
word_counts.update(morewords)   ## does the same work as the above addiotion op.
```

:trophy: The **`Counter` object** also supports common **mathematical** 
operations like _sum_, _difference_ etc.

```python
from collections import Counter
words = [&quot;hello&quot;, &quot;world&quot;, &quot;hello&quot;, &quot;world&quot;, &quot;earth&quot;]
morewords = [&quot;hello&quot;, &quot;vinay&quot;, &quot;earth&quot;]

a = Counter(words)          ## {&quot;hello&quot;:2, &quot;world&quot;:2, &quot;earth&quot;:1}
b = Counter(morewords)      ## {&quot;hello&quot;:1, &quot;vinay&quot;:1, &quot;earth&quot;:1}

## adding the two counter objects together
a + b                                       ## {&quot;hello&quot;:3, &quot;world&quot;:2, &quot;earth&quot;:2, &quot;vinay&quot;:1}

## subtracting the two counter objects
a - b                                       ## {&quot;hello&quot;:1, &quot;world&quot;:2, &quot;vinay&quot;:1}
```
</code></pre>
<h2 id="113-sorting-a-list-of-dicts-by-a-common-key">1.13: Sorting a List of dicts by a common key <a href="#113-sorting-a-list-of-dicts-by-a-common-key" class="hash">#</a></h2>
<p>???+ danger &ldquo;Problem&rdquo;
You have a list of dictionaries and you would like to sort the items according to
one or more of the dict values</p>
<p>???+ done &ldquo;Solution&rdquo;
Sorting this type of structure is easy using <strong><code>operator</code></strong> module&rsquo;s <strong><code>itemgetter()</code></strong> function.
Let&rsquo;s say you&rsquo;ve queried a database table to get a listing of the members on your website,
and you receive the following data structure in return.</p>
<pre><code>```python
rows = [
    {'fname': 'Brian', 'lname': 'Jones', 'uid': 1003},
    {'fname': 'David', 'lname': 'Beazley', 'uid': 1002},
    {'fname': 'John', 'lname': 'Cleese', 'uid': 1001},
    {'fname': 'Big', 'lname': 'Jones', 'uid': 1004}
]
```
It is fairly easy to output these rows ordered by any of the _fields_ **common** to all of the rows in the dict.
For example:

```python
from operator import itemgetter

rows_by_fname = sorted(rows, key=itemgetter(&quot;fname&quot;))
rows_by_uid = sorted(rows, key=itemgetter(&quot;uid&quot;))
```
```python
print(rows_by_fname)
```
```
[{'fname': 'Big', 'uid': 1004, 'lname': 'Jones'},
 {'fname': 'Brian', 'uid': 1003, 'lname': 'Jones'},
 {'fname': 'David', 'uid': 1002, 'lname': 'Beazley'},
 {'fname': 'John', 'uid': 1001, 'lname': 'Cleese'}]
```
```python
print(rows_by_uid)
```
```
[{'fname': 'John', 'uid': 1001, 'lname': 'Cleese'},
 {'fname': 'David', 'uid': 1002, 'lname': 'Beazley'},
 {'fname': 'Brian', 'uid': 1003, 'lname': 'Jones'},
 {'fname': 'Big', 'uid': 1004, 'lname': 'Jones'}]
```

:trophy: The **`itemgetter()`** function also accepts **multiple** keys as arguments

```python
rows_by_lfname = sorted(rows, key=itemgetter(&quot;lname&quot;, &quot;fname&quot;))
print(rows_by_lfname)
```
```
[{'fname': 'David', 'uid': 1002, 'lname': 'Beazley'},
 {'fname': 'John', 'uid': 1001, 'lname': 'Cleese'},
 {'fname': 'Big', 'uid': 1004, 'lname': 'Jones'},
 {'fname': 'Brian', 'uid': 1003, 'lname': 'Jones'}]
```
</code></pre>
<p>???+ quote &ldquo;Discussion&rdquo;
In this example, <code>rows</code> is passed to the built-in <strong><code>sorted()</code></strong> function which accepts a keyword
argument <strong><code>key</code></strong>. The <strong><code>key</code></strong> argument is expected to be a callable that accepts a single item
from <code>rows</code> as input and returns a single value that is used as a basis for sorting.
The <strong><code>itemgetter()</code></strong> is just such a callable.</p>
<pre><code>The **`operator.itemgetter()`** function takes as argument the lookup indices 
which is used to extract the desired values from the records in the `rows`.
It can be a dictionary key name, a numeric list element, or any value that can be fed to the 
object's **`__getitem__()`** method.

:rotating_light: If you give multiple indices to **`itemgetter()`**, the callable it produces will return 
a **tuple** with all the indexed elements into it; which is then passed to the **`sorted()`** function.
This is important if you want to simulatenously sort on multiple fields 
(as shown in above example `rows_by_lfname`, ie.e sorting by `lname` first then by `fname`).

The functionality of **`itemgetter()`** is sometimes replaced by **`lambda`** expressions, 

```python
rows_by_fanme = sorted(rows, key=lambda r: r[&quot;fname&quot;])
rows_by_lfname = sorted(rows, key=lambda r: (r[&quot;lname&quot;], r[&quot;fname&quot;]))
```

:trophy: But **`itemgetter()`** is **faster** than `lambda` expressions.

:trophy: Note that this technique can also be used for other functions that does their operations
which require `key` callable function such as **`min()`**, **`max()`** etc.

```python
from operator import itemgetter
min(rows, key=itemgetter(&quot;uid&quot;))    ## {'fname': 'John', 'lname': 'Cleese', 'uid': 1001}
max(rows, key=itemgetter(&quot;uid&quot;))    ## {'fname': 'Big', 'lname': 'Jones', 'uid': 1004}
```
</code></pre>
<h2 id="114-sorting-objects-wo-native-comparision-support">1.14: Sorting objects w/o native comparision support <a href="#114-sorting-objects-wo-native-comparision-support" class="hash">#</a></h2>
<p>???+ danger &ldquo;Problem&rdquo;
You want to sort objects of the same class; but they don&rsquo;t natively support comparision operation.</p>
<p>???+ done &ldquo;Solution&rdquo;
The built-in <strong><code>sorted()</code></strong> function takes a <strong><code>key</code></strong> argument that can be passed a callable
that will return a value in the object that <strong><code>sorted()</code></strong> will use to compare the objects.</p>
<pre><code>For example, if you have sequence of `User` instances and you want to sort the items in the sequence
using their `used_id` attribute; you would supply a **callable** that will take a `User` instance 
as input and return the `user_id` of that input which can then be used by **`sorted()`** function
as a key to sort the instances in the sequence. This is illustrated in the below code.

```python hl_lines=&quot;12&quot;
class User:
    def __init__(self, user_id):
    self.user_id = user_id

    def __repr__(self):
        return f&quot;User({self.user_id})&quot;

## ---------------------------------------------- ##

users = [User(23), User(1), User(9)]

sorted(users, key=lambda u: u.user_id)  ## [User(1), User(9), User(23)]
```

:trophy: Instead of using `lambda`, you can use a faster **`operator.attrgetter()`** function

```python hl_lines=&quot;2&quot;
from operator import attrgetter
sorted(users, key=attrgetter(&quot;user_id&quot;))    ## [user(1), User(9), User(23)]
```
</code></pre>
<p>???+ quote &ldquo;Discussion&rdquo;
The choice of whether to use <code>lambda</code> or <code>operator.attrgetter()</code> is personal,
but <strong><code>operator.attrgetter()</code></strong> is a bit faster and <strong>supports multiple attribute indexing</strong>
as shown below.</p>
<pre><code>Suppose the `User` class has two attributes `user_id` and `user_name` and we want to sort
sequence of `User` instances based on both these attributes; then we can use **`operator.attrgetter()`**
very easily.

```python
from operator import attrgetter

## assume that &quot;User&quot; class has two attributes &quot;user_id&quot; and &quot;user_name&quot;
sorted(users, key=attrgetter(&quot;user_id&quot;, &quot;user_name&quot;))
```

:rotating_light: This behavior of **`attrgetter()`** is analogous to **`itemgetter()`** function (used for **dictionaries**)

:trophy: Similar to `itemgetter()`, we can use `attrgetter()` for other 
comparision operations that require a `key` attribute such as **`min()`, `max()`** etc.

```python
min(users, key=attrgetter(&quot;user_id&quot;))
max(users, key=attrgetter(&quot;user_id&quot;))
```
</code></pre>

      </span>
       

    </section>
    <hr>
<footer>
	  <nav>
      
  <ul>
    <li>
      © 2025
    </li>
  
  </ul>
    </nav>
</footer>

  </main>
</body>
</html>
