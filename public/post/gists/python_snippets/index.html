<!doctype html><html lang=en><head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=livereload" data-no-instant defer></script><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=author content="Ronalds Vilcins - http://localhost:1313/"><title>| Vinay Kumar</title>
<meta name=description content><meta name=twitter:card content="summary"><meta name=twitter:title content><meta name=twitter:description content="Python Snippets # 1: MappingProxyType # ???+ quote &ldquo;Immutable Mappings&rdquo; The mapping types provided by the standard library are all mutable; but you may need to gurantee that a user cannot change a mapping by mistake.
Since `Python 3.3` the `types` module provides a wrapper class `MappingProxyType` which, given a mapping returns a `mappingproxy` instance that is **read-only** but a **dynamic-view** of the original mapping. This means that the original mapping can be seen through `mappingproxy` but changes cannot be made through it."><meta property="og:title" content><meta property="og:description" content="Python Snippets # 1: MappingProxyType # ???+ quote &ldquo;Immutable Mappings&rdquo; The mapping types provided by the standard library are all mutable; but you may need to gurantee that a user cannot change a mapping by mistake.
Since `Python 3.3` the `types` module provides a wrapper class `MappingProxyType` which, given a mapping returns a `mappingproxy` instance that is **read-only** but a **dynamic-view** of the original mapping. This means that the original mapping can be seen through `mappingproxy` but changes cannot be made through it."><meta property="og:type" content="article"><meta property="og:url" content="http://localhost:1313/post/gists/python_snippets/"><meta property="article:section" content="post"><meta itemprop=name content><meta itemprop=description content="Python Snippets # 1: MappingProxyType # ???+ quote &ldquo;Immutable Mappings&rdquo; The mapping types provided by the standard library are all mutable; but you may need to gurantee that a user cannot change a mapping by mistake.
Since `Python 3.3` the `types` module provides a wrapper class `MappingProxyType` which, given a mapping returns a `mappingproxy` instance that is **read-only** but a **dynamic-view** of the original mapping. This means that the original mapping can be seen through `mappingproxy` but changes cannot be made through it."><meta itemprop=wordCount content="354"><meta itemprop=keywords content><link rel=canonical href=http://localhost:1313/post/gists/python_snippets/><link rel=dns-prefetch href=https://www.google-analytics.com><link href=https://www.google-analytics.com rel=preconnect crossorigin><link rel=alternate type=application/atom+xml title="Vinay Kumar" href=http://localhost:1313/atom.xml><link rel=alternate type=application/json title="Vinay Kumar" href=http://localhost:1313/feed.json><link rel="shortcut icon" type=image/png href="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAQAAAC1HAwCAAAAC0lEQVR42mNk+A8AAQUBAScY42YAAAAASUVORK5CYII="><style>*,:after,:before{box-sizing:border-box;padding:0}body{font:1rem/1.5 '-apple-system',BlinkMacSystemFont,avenir next,avenir,helvetica,helvetica neue,ubuntu,roboto,noto,segoe ui,arial,sans-serif;text-rendering:optimizeSpeed}.posts hr{margin-top:0;margin-bottom:0;margin-right:.5rem;margin-left:.5rem;height:1px;border:none;border-bottom:1px #353535;flex:1 0 1rem}main{max-width:70ch;padding:2ch;margin:auto}a,body{color:#353535}::selection,a:focus,a:hover{background-color:#353535;color:#fff}.meta{margin:0 0 2.5rem}.tags::before{content:"\2022";margin-left:1rem}code,pre{color:#353535;font-family:San Francisco Mono,Monaco,consolas,lucida console,dejavu sans mono,bitstream vera sans mono,monospace;font-size:normal;border:1px solid #353535;font-size:small}.highlight [class^=language-]{color:#fff}code{padding:.1rem;border:none}pre{padding:.5rem;overflow-x:auto}pre code{border:none}img{max-width:100%;border:1px solid #353535}hr{background:#353535;height:1px;border:0}ul{list-style-type:square}ul,ol{padding-left:1.2rem}header li,footer li{display:inline;text-transform:uppercase}header a,footer a{text-decoration:none}header ul,footer ul{justify-content:space-between;display:flex}[aria-current=page]{text-decoration:line-through}header,section,footer{padding:1rem 0}blockquote{border-left:5px solid #353535;padding-left:1rem}.posts ul,header ul,footer ul{list-style:none}.posts,header ul,footer ul{padding:0}.posts li{align-items:center;display:flex;justify-content:space-between;margin-bottom:.7rem}.posts li a,.posts li div{white-space:nowrap;overflow:hidden;text-overflow:ellipsis;text-decoration:none}.posts li time{padding-left:1rem;white-space:nowrap;font-variant-numeric:tabular-nums}.hash{opacity:.25;text-decoration:none}table{border-collapse:collapse;text-align:left;width:100%}table tr{background:#fff;border-bottom:1px solid}table th,table td{padding:10px 20px}</style><script type=application/ld+json>{"@context":"http://schema.org","@type":"BlogPosting","articleSection":"post","name":"","headline":"","alternativeHeadline":"","description":"Python Snippets # 1: MappingProxyType # ???\u002b quote \u0026ldquo;Immutable Mappings\u0026rdquo; The mapping types provided by the standard library are all mutable; but you may need to gurantee that a user cannot change a mapping by mistake.\nSince \u0060Python 3.3\u0060 the \u0060types\u0060 module provides a wrapper class \u0060MappingProxyType\u0060 which, given a mapping returns a \u0060mappingproxy\u0060 instance that is **read-only** but a **dynamic-view** of the original mapping. This means that the original mapping can be seen through \u0060mappingproxy\u0060 but changes cannot be made through it.","inLanguage":"en-us","isFamilyFriendly":"true","mainEntityOfPage":{"@type":"WebPage","@id":"http:\/\/localhost:1313\/post\/gists\/python_snippets\/"},"author":{"@type":"Person","name":""},"creator":{"@type":"Person","name":""},"accountablePerson":{"@type":"Person","name":""},"copyrightHolder":"Vinay Kumar","copyrightYear":"0001","dateCreated":"0001-01-01T00:00:00.00Z","datePublished":"0001-01-01T00:00:00.00Z","dateModified":"0001-01-01T00:00:00.00Z","publisher":{"@type":"Organization","name":"Vinay Kumar","url":"http://localhost:1313/","logo":{"@type":"ImageObject","url":"http:\/\/localhost:1313\/","width":"32","height":"32"}},"image":"http://localhost:1313/","url":"http:\/\/localhost:1313\/post\/gists\/python_snippets\/","wordCount":"354","genre":[],"keywords":[]}</script></head><body><main><header><nav><ul><li><a href=/>Index</a></li><li><a href=/about/>About</a></li><li><a href=/atom.xml>RSS</a></li></ul></nav></header><hr><section><span itemprop=articleBody><h1 id=python-snippets>Python Snippets <a href=#python-snippets class=hash>#</a></h1><h2 id=1-mappingproxytype><code>1: MappingProxyType</code> <a href=#1-mappingproxytype class=hash>#</a></h2><p>???+ quote &ldquo;Immutable Mappings&rdquo;
The mapping types provided by the standard library are all mutable;
but you may need to gurantee that a user cannot change a mapping by mistake.</p><pre><code>Since `Python 3.3` the `types` module provides a wrapper class `MappingProxyType` which,
given a mapping returns a `mappingproxy` instance that is **read-only** but a **dynamic-view** 
of the original mapping. 

This means that the original mapping can be seen through `mappingproxy`
but changes cannot be made through it.

```python
from types import MappingProxyType

d = {1:&quot;A&quot;}
d_proxy = MappingProxyType(d)   ## creating a proxy for the original dict d
                                ## d_proxy = {1:&quot;A&quot;}
print(d_proxy[1])               ## &quot;A&quot;
d_proxy[2] = &quot;X&quot;                ## TypeERROR. mappingproxy does not support item assignment

d[2] = &quot;B&quot;                      ## OKAY. The original dictionary is still mutable

print(d_proxy)                  ## The proxy has a dynamic view of the original dict. 
                                ## So, it refelects the change
                                ## {1:&quot;A&quot;, 2:&quot;B&quot;}
```
</code></pre><h2 id=2-set-operators><code>2: Set operators</code> <a href=#2-set-operators class=hash>#</a></h2><p>???+ quote &ldquo;Set Operators&rdquo;
```markdown
<strong>operator: method: desciption:</strong>
<code>s.isdisjoint(z)</code> <code>s</code> and <code>z</code> are disjoint (i.e. have no elements in common)
<code>e in s</code> <code>s.__contains__(e)</code> element <code>e</code> is a subset of <code>s</code> set</p><pre><code>`s &lt;= z`        `s.__le__(z)`               `s` is a **subset** of `z` set
                `s.issubset(it)`            `s` is a **subset** of the set built from the iterable `it`
`s &lt; z`         `s.__lt__(z)`               `s` is a **PROPER-subset** of `z` set

`s &gt;= z`        `s.__ge__(z)`               `s` is a **superset** of `z` set
                `s.issuperset(it)`          `s` is a **superset** of the set built from iterable `it`
`s &gt; z`         `s.__gt__(z)`               `s` is a **PROPER-superset** of the set `z`
```
</code></pre><h2 id=3-set-vs-frozenset><code>3: set v/s frozenset</code> <a href=#3-set-vs-frozenset class=hash>#</a></h2><p>???+ quote &ldquo;Set v/s Frozenset&rdquo;
<code>markdown **operator: set: frozenset: description:** `s.add(e)` ✅ Add element `e` to set `s` `s.clear()` ✅ Remove all elements from set `s` `s.copy()` ✅ ✅ Shallow copy of set/frozenset `s` `s.discard(e)` ✅ Remove element `e` from set `s` IF it is present `s.__iter__()` ✅ ✅ Get iterator over set/frozenset `s` `s.__len__()` ✅ ✅ `len(s)` `s.pop()` ✅ Remove and return an element from `s`; raising `keyError` if `s` is empty `s.remove(e)` ✅ Remive element `e` from set `s`; raise `KeyError` if `e not in s`</code></p></span></section><hr><footer><nav><ul><li>© 2025</li></ul></nav></footer></main></body></html>